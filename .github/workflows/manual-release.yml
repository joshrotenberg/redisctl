name: Manual Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Version bump type or explicit version"
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
          - current
        default: patch
      dry_run:
        description: "Dry run (do not publish)"
        required: false
        type: boolean
        default: false

permissions:
  contents: write

jobs:
  release:
    name: Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global init.defaultBranch main
          git config --global push.autoSetupRemote true

      - name: Cache cargo registry and tools
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
          key: ${{ runner.os }}-cargo-tools-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-tools-

      - name: Install cargo-release
        run: |
          if ! command -v cargo-release &> /dev/null; then
            echo "Installing cargo-release..."
            cargo install cargo-release
          else
            echo "cargo-release already installed"
          fi

      - name: Verify crates.io authentication
        if: ${{ !inputs.dry_run }}
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
        run: |
          echo "Verifying crates.io authentication..."

          # Check if token is set (don't print it!)
          if [ -z "$CARGO_REGISTRY_TOKEN" ]; then
            echo "::error::CARGO_REGISTRY_TOKEN is not set!"
            exit 1
          fi

          # Show token metadata (length and first few chars only for debugging)
          TOKEN_LENGTH=${#CARGO_REGISTRY_TOKEN}
          echo "Token is set (length: $TOKEN_LENGTH)"

          # Verify token format (should start with specific prefix)
          if [[ ! "$CARGO_REGISTRY_TOKEN" =~ ^[a-zA-Z0-9_-]{20,} ]]; then
            echo "::warning::Token format may be invalid"
          fi

          # Test authentication with cargo
          echo "Testing cargo login..."
          cargo login "$CARGO_REGISTRY_TOKEN"

          # Test with dry-run publish on smallest package
          echo "Testing publish access with dry-run..."
          cd crates/redis-cloud
          if cargo publish --dry-run 2>&1 | tee /tmp/publish-test.log; then
            echo "✓ Successfully authenticated to crates.io"
          else
            echo "::error::Failed to authenticate to crates.io"
            echo "Debug output:"
            cat /tmp/publish-test.log
            exit 1
          fi
          cd ../..

          # Verify all packages can be published
          echo "Verifying all packages..."
          for pkg in redis-cloud redis-enterprise redisctl; do
            echo "  Checking $pkg..."
            cd crates/$pkg
            if ! cargo publish --dry-run --allow-dirty > /dev/null 2>&1; then
              echo "::error::Package $pkg cannot be published"
              cargo publish --dry-run --allow-dirty
              exit 1
            fi
            cd ../..
          done

          echo "✓ All packages verified for publishing"

      - name: Dry Run Release
        if: inputs.dry_run
        run: |
          echo "Running dry run for ${{ inputs.version }} version bump..."
          cargo release version ${{ inputs.version }} --execute --no-confirm --verbose
          cargo release replace --execute --no-confirm --verbose
          cargo release hook --execute --no-confirm --verbose
          echo "Dry run complete - no changes were pushed"

      - name: Execute Release
        if: ${{ !inputs.dry_run }}
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
          CARGO_TERM_COLOR: always
          RUST_BACKTRACE: full
          RUST_LOG: cargo_release=debug
        run: |
          echo "Releasing ${{ inputs.version }} version..."

          # Debug: Show current state
          echo "Current directory: $(pwd)"
          echo "Git status:"
          git status
          echo ""

          # Handle "current" version option - release without bumping
          if [ "${{ inputs.version }}" = "current" ]; then
            echo "Releasing current version without bumping..."

            # Get current version
            CURRENT_VERSION=$(cargo metadata --no-deps --format-version 1 | jq -r '.workspace.metadata.package.version // .packages[0].version')
            echo "Current version: $CURRENT_VERSION"

            # Run cargo-release with the explicit version to skip bumping
            echo "Executing release of v$CURRENT_VERSION..."
            cargo release $CURRENT_VERSION \
              --execute --no-confirm --verbose 2>&1 | tee /tmp/release.log || {
              echo "::error::cargo-release failed. Check the logs above for details."
              exit 1
            }
          else
            # Debug: Show what cargo-release will do
            echo "Checking what cargo-release will do..."
            cargo release ${{ inputs.version }} --list 2>&1 | tee /tmp/release-list.log || true

            if ! grep -q "redis-cloud\|redis-enterprise\|redisctl" /tmp/release-list.log; then
              echo "::warning::No packages detected by cargo-release. Debug info:"
              echo "Workspace members:"
              cargo metadata --no-deps --format-version 1 | jq -r '.workspace_members[]'
              echo ""
              echo "Package metadata:"
              for pkg in redis-cloud redis-enterprise redisctl; do
                echo "Package: $pkg"
                cargo metadata --no-deps --format-version 1 | jq ".packages[] | select(.name == \"$pkg\") | {name, version, publish}"
              done
            fi

            # Run cargo-release - it will handle everything
            # Use workspace-level release with shared-version
            echo "Executing release..."
            cargo release ${{ inputs.version }} \
              --execute --no-confirm --verbose 2>&1 | tee /tmp/release.log || {
              echo "::error::cargo-release failed. Check the logs above for details."
              echo ""
              echo "Failure analysis:"
              if grep -q "no packages selected" /tmp/release.log; then
                echo "- cargo-release couldn't find packages to release"
                echo "- This usually means a configuration or authentication issue"
              fi
              if grep -q "failed to connect" /tmp/release.log; then
                echo "- Network/authentication issue detected"
                echo "- Verify CARGO_REGISTRY_TOKEN is valid"
              fi
              exit 1
            }
          fi

      - name: Report Status
        if: always()
        run: |
          echo "Release status: ${{ job.status }}"
          if [ "${{ job.status }}" = "failure" ]; then
            echo "::error::Release failed. Check logs above."
            echo "Recovery steps if needed:"
            echo "1. Delete partial tags: git push --delete origin v[VERSION]"
            echo "2. Delete local tag: git tag -d v[VERSION]"
            echo "3. Yank from crates.io if partially published"
            echo "4. Revert commits if necessary: git revert HEAD"
          elif [ "${{ job.status }}" = "success" ] && [ "${{ inputs.dry_run }}" != "true" ]; then
            echo "::notice::Release completed successfully!"
            echo "Next steps:"
            echo "1. Wait for cargo-dist workflow to build binaries"
            echo "2. Wait for Docker workflow to build images"
            echo "3. Verify packages on crates.io"
          fi
